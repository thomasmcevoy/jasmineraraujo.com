"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var base_service_1 = __importDefault(require("./base-service"));
/**
 * The interface that all fulfillment services must inherit from. The intercace
 * provides the necessary methods for creating, authorizing and managing
 * fulfillment orders.
 * @interface
 */
var BaseFulfillmentService = /** @class */ (function (_super) {
    __extends(BaseFulfillmentService, _super);
    function BaseFulfillmentService() {
        return _super.call(this) || this;
    }
    BaseFulfillmentService.prototype.getIdentifier = function () {
        return this.constructor.identifier;
    };
    /**
     * Called before a shipping option is created in Admin. The method should
     * return all of the options that the fulfillment provider can be used with,
     * and it is here the distinction between different shipping options are
     * enforced. For example, a fulfillment provider may offer Standard Shipping
     * and Express Shipping as fulfillment options, it is up to the store operator
     * to create shipping options in Medusa that can be chosen between by the
     * customer.
     */
    BaseFulfillmentService.prototype.getFulfillmentOptions = function () {
        throw Error("getFulfillmentOptions must be overridden by the child class");
    };
    /**
     * Called before a shipping method is set on a cart to ensure that the data
     * sent with the shipping method is valid. The data object may contain extra
     * data about the shipment such as an id of a drop point. It is up to the
     * fulfillment provider to enforce that the correct data is being sent
     * through.
     * @param {object} optionData - the data to validate
     * @param {object} data - the data to validate
     * @param {object | undefined} cart - the cart to which the shipping method will be applied
     * @return {object} the data to populate `cart.shipping_methods.$.data` this
     *    is usually important for future actions like generating shipping labels
     */
    BaseFulfillmentService.prototype.validateFulfillmentData = function (optionData, data, cart) {
        throw Error("validateFulfillmentData must be overridden by the child class");
    };
    /**
     * Called before a shipping option is created in Admin. Use this to ensure
     * that a fulfillment option does in fact exist.
     */
    BaseFulfillmentService.prototype.validateOption = function (data) {
        throw Error("validateOption must be overridden by the child class");
    };
    BaseFulfillmentService.prototype.canCalculate = function (data) {
        throw Error("canCalculate must be overridden by the child class");
    };
    /**
     * Used to calculate a price for a given shipping option.
     */
    BaseFulfillmentService.prototype.calculatePrice = function (optionData, data, cart) {
        throw Error("calculatePrice must be overridden by the child class");
    };
    BaseFulfillmentService.prototype.createFulfillment = function (data, items, order, fulfillment) {
        throw Error("createFulfillment must be overridden by the child class");
    };
    BaseFulfillmentService.prototype.cancelFulfillment = function (fulfillment) {
        throw Error("cancelFulfillment must be overridden by the child class");
    };
    /**
     * Used to retrieve documents associated with a fulfillment.
     * Will default to returning no documents.
     */
    BaseFulfillmentService.prototype.getFulfillmentDocuments = function (data) {
        return [];
    };
    /**
     * Used to create a return order. Should return the data necessary for future
     * operations on the return; in particular the data may be used to receive
     * documents attached to the return.
     */
    BaseFulfillmentService.prototype.createReturn = function (fromData) {
        throw Error("createReturn must be overridden by the child class");
    };
    /**
     * Used to retrieve documents related to a return order.
     */
    BaseFulfillmentService.prototype.getReturnDocuments = function (data) {
        return [];
    };
    /**
     * Used to retrieve documents related to a shipment.
     */
    BaseFulfillmentService.prototype.getShipmentDocuments = function (data) {
        return [];
    };
    BaseFulfillmentService.prototype.retrieveDocuments = function (fulfillmentData, documentType) {
        throw Error("retrieveDocuments must be overridden by the child class");
    };
    return BaseFulfillmentService;
}(base_service_1.default));
exports.default = BaseFulfillmentService;
//# sourceMappingURL=fulfillment-service.js.map